package project.course.function

import java.io.File
import kotlin.random.Random

 /**
  * Объект получатель(экземпляр типа)(this) - тип или объект  для которого была вызвана функция,
  * например (Int, List, Any, String,Context) и т.д
  * Результат лямбды выражения, это то что лямбда в итоге возвращает
  */

fun main() {


    val name: String? = "Osman"

    /**
     * apply - она позволяет вызвать несколько функций для объекта-получателья, после выполнения
     * указанного лямбда выражения apply возвращает настроеннный объект-получателья,
     * для обращения к содержимому используется this, но его можно опустить
     */

    val file = File("D:\\ic_eva_logo.xml").apply {
        setReadable(true) // На самом деле, file.setReadable(true)
        setWritable(true)
        setExecutable(false)
    }


    /**
     * let - обычно используется для того что бы избавиться от nullable по умолчанию она создает
     * переменную it для обращения [и он возвращает -Результат лямбды выражения ]
     */
    name?.let {
        if (it.length > 5) {
            println(it)
        }
    }


    /**
     * with - была придумана для случаев, когда нам нужно произвести множество операций с одним и
     * тем же обьектом, в качестве параметра она принимает любой обьект, а для обращения
     * используется this, но его можно и опустить
     * [и он возвращает -Результат лямбды выражения ] - рекомендуется использовать run вместо with
     */
    with(name) {
        this?.length
        this?.split(",")
        this?.get(2) //лямбда вернет элемент по индексу

    }


    /**
     * run - похожа на apply, но в отличий от него run возвращает результат лямбды -  в нашем
     * случае boolean run так же принимает ссылку на функцию
     */

    val menuFile = File("D:\\ic_eva_logo.xml").run {
        this.readText().contains("some")
    }


    /**
     * also - похожа на let? , он передает объект применик в лямбду,  но возвращает обЪект
     * приемник, а не результат лямбды
     */
    File("D:\\ic_eva_logo.xml").also {
        println(it.name)
    }.also {
        val array = it.readLines()
    }


    /**
     * takeIf - вычесялет условие или predicate(функуцию) заданное в лямбде которая возвращает
     * boolean, если true то результат то вернёт объект применик, а если лож то null
     */
    val array = arrayOf(1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10)
    array.takeIf { it.size > 10 }


    //OTHER EXAMPLE


    val random = Random.nextInt()

    /**
     * Also - принмает лямбду, и передает обьект применик в лямбду(сама лямбда нечего не
     * возвращает), а  функция возвращает сам объект применик без изминений типа
     */
    val also = random.also {
        it.toString()
    }


    /**
     * apply-принимает лямбду-рассширение, лямбда вызваеться для объекта приемника(но сама нечего
     * не возвращает), а функция возвраащет сам объект приемник
     */
    val apply = random.apply {

    }


    /**
     * let - принмает лямбду, и передает обьект применик в лямбду, лямбда  возвращает измененный
     * тип, а сама функция возвафщает результат лямбды
     */
    val let = random.let {
        it.toString()
    }


    /**
     * run - принимает лямбду-рассширение, лямбда вызваеться для объекта приемника,
     * лямбда  возвращает измененный тип, а сама функция возвафщает результат лямбды
     */
    val run = random.run {

    }

    run{

    }


    /**
     * with - принимает объект применик а так же лямбду-рассширение, и возвращает результат лямбды
     */
    val with = with(random) {

    }

}
