package delegate.delegates

/**
 * Created by osmanboy on 1/30/2022
 */
/**
 * Паттерн делегат очень простой:один объект передает выполнение своего метода другому объекту.
 * Например,в Kotlin это выглядит так:
 */
internal interface Flyable {
    fun flyToRight()
    fun flyToLeft()
}

internal class Plane : Flyable {
    override fun flyToRight() = println("Лечу на право!")


    override fun flyToLeft() = println("Лечу на лево!")

}

/**
 * 1.Теперь во первых мы должны писать код на уровне абстракций, а не реализаций.
 * 2.Так же, что если класс, чей код мы хотим наследовать, можем быть как final(запрещен для наследования)
 * 3.Что если наш класс уже имеет родителя, то есть уже наследован от какого-то класса, то мы не можем наследоваться
 * от двух классов одновременно.
 * В таких случаях на помощь приходит паттерн Делегирование.
 * Тоже самое но в Java: [delegate.delegates.java.JavaTestFlyable]
 */
internal class Bird(private val flyable: Flyable) : Flyable by flyable {

    /**
     * Нет нет, я не забыл реализовать метод [flyToRight] у Птицы, он там реализован.
     * Разве не видно? Вот в этой строчке: Flyable by flyable.
     * Эта языковая конструкция с использованием ключевого слова by говорит, что реализацию методов интерфейса Flyable
     * нужно делегировать полю flyable. При этом декомпилированный в Java код выглядит так же
     * как и пример на Java: [delegate.delegates.java.JavaTestFlyable].
     *
     * Что в этом плохого? Ведь теперь тривиальные реализации интерфейсов можно будет не писать.
     * Вот, какой минус вижу я:
     *    -Теряется контроль за зоной ответственности объекта, так как непосредственные реализации будут скрыты от
     *     взгляда программиста. На ревью сложно оценить количество методов у класса, который использует Class Delegation
     *
     *
     * Допустим, вы читаете чужой код, видите там строчку:
     *    -bird.flyToRight()
     * И, вам надо узнать, что происходит в методе [flyToRight].
     * Вы знаете, что этот метод вызывается у объекта класса [Bird],
     * поэтому вы открываете код этого класса и … там нет метода [flyToRight].
     * П - паника. Конечно, через пару часов вы увидите, что там Class Delegation,и метод просто скрыт.
     * И вы потеряете больше времени на понимание происходящего, чем если бы там был делегат здорового человека.
     * Делегат здорового человека - курильщика
     *
     * Используя делегаты в Koltin вы обрекаете себя на более высокую стоимость разработки.

     */
    // тут мы создали свою реализацию.
    override fun flyToLeft() = println("Лечу на лево опускаясь ниже!")

}

fun main() {
    val flyable: Flyable = Plane() //конкретная реализация интерфейса Flyable
    val bird = Bird(flyable) //передаем объект типа Flyable
    bird.flyToLeft() //наша собственная реализация.
    bird.flyToRight() // реализация из класса Plane
}
